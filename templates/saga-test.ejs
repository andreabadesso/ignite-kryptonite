import FixtureAPI from '../../Services/FixtureApi'
import { call, put, select } from 'redux-saga/effects'
import { get<%= props.name %>, post<%= props.name %>,  edit<%= props.name %>, delete<%= props.name %> } from '../../Sagas/<%= props.name %>Sagas'
import <%= props.name %>Actions, { INITIAL_STATE } from '../../Redux/<%= props.name %>Redux'
import R from 'ramda'

const action = { type: '<%= props.name %>',  data: { someKey: 'someValue' } }
const dataFixture = INITIAL_STATE.data

it('posts successfully', () => {
  let actual, response

  let saga = post<%= props.name %>(FixtureAPI, action)

  actual = saga.next(action.data).value
  expect(actual).toEqual(call(FixtureAPI.post<%= pascalCase(props.name) %>, action.data))
  response = { ok: true, data: { someKey: 'someValue'}}

  actual = saga.next(response).value
  expect(actual).toEqual(put(<%= props.name %>Actions.<%= camelCase(props.name) %>Success(response.data)))
})

it('posts, but the server returns an error', () => {
  let actual, response

  let saga = post<%= props.name %>(FixtureAPI, action)

  actual = saga.next(action.data).value
  expect(actual).toEqual(call(FixtureAPI.post<%= pascalCase(props.name) %>, action.data))
  response = { ok: false, data: {
    errors: [{ detail: "An error goes here" }]
    }
  }

  actual = saga.next(response).value
  expect(actual).toEqual(put(<%= props.name %>Actions.<%= camelCase(props.name) %>Failure(response.data.errors)))
})
